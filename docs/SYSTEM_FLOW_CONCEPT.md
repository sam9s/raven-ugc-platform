# UGC Video Generation System - Conceptual Flow

## The Big Picture

Think of the system as a **production pipeline** where:
1. User provides basic product info (name, features, target audience)
2. AI generates a realistic product image
3. AI analyzes that image to understand what it sees
4. AI generates a video based on the image and product context
5. Everything gets saved to the database with credits tracked

---

## Current State vs Future State

### **RIGHT NOW (What We're Testing)**
- **No frontend exists** - we're using curl commands to manually trigger the workflow
- We manually create a video record in Supabase first
- Then we call the webhook with product info
- The workflow runs for 5-6 minutes generating the video
- Results get saved back to the database

### **FUTURE STATE (What We'll Build)**
- User logs into React frontend (Lovable → React migration)
- User fills a form: product name, features, target audience, upload photo
- Frontend creates database record and calls n8n webhook automatically
- User sees real-time progress (processing → completed)
- User downloads the final video from dashboard

---

## The 5 Key Questions Answered

### 1. **How Does the Webhook Get Executed?**

**Current Testing Method:**
```bash
curl -X POST https://n8n.sam9scloud.in/webhook/ugc-video-generate \
  -H "Content-Type: application/json" \
  -H "X-API-Key: your-secret-key" \
  -d '{
    "user_id": "42a140a2-b4c5-4e2e-92bd-449e87f52605",
    "video_id": "bbbbbbbb-cccc-dddd-eeee-000000000001",
    "product_name": "Wireless Earbuds Pro",
    "product_category": "Electronics",
    "key_features": ["Active noise cancellation", "30-hour battery"],
    "target_audience": "Tech-savvy millennials"
  }'
```

**Future Frontend Method:**
```javascript
// User clicks "Generate Video" button in React app
const response = await fetch('https://n8n.sam9scloud.in/webhook/ugc-video-generate', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-API-Key': process.env.WEBHOOK_SECRET
  },
  body: JSON.stringify({
    user_id: currentUser.id,
    video_id: newVideoRecord.id,
    product_name: formData.productName,
    product_category: formData.category,
    key_features: formData.features,
    target_audience: formData.audience
  })
});
```

**The webhook is just an HTTPS endpoint** - anyone with the URL and API key can trigger it. In production, only your frontend will have the API key.

---

### 2. **Where Does the Image Prompt Come From?**

This is where **OpenAI GPT-4o-mini** comes in. Here's the exact flow:

**Step 1: User Provides Raw Product Info**
```json
{
  "product_name": "Wireless Earbuds Pro",
  "product_category": "Electronics",
  "key_features": ["Active noise cancellation", "30-hour battery", "IPX7 waterproof"],
  "target_audience": "Tech-savvy millennials who commute daily"
}
```

**Step 2: Workflow Sends This to OpenAI**
The "Generate Image Prompt" node (Node 8) sends this request to OpenAI:

```
System: You are an expert at creating prompts for FLUX image generation...

User: Generate a product photo prompt for:
- Product: Wireless Earbuds Pro
- Category: Electronics
- Features: Active noise cancellation, 30-hour battery, IPX7 waterproof
- Audience: Tech-savvy millennials who commute daily
```

**Step 3: OpenAI Returns a Detailed Image Prompt**
```
"Professional product photography of wireless earbuds in matte black finish,
displayed on a clean white surface with soft studio lighting. The earbuds should
show premium build quality with visible IPX7 waterproof sealing. Shot from a
45-degree angle with shallow depth of field, emphasizing the sleek ergonomic
design. Include subtle reflections to suggest high-end materials. 8K resolution,
commercial photography style."
```

**Step 4: This Prompt Goes to KIE.AI FLUX**
The workflow then sends this polished prompt to FLUX Kontext Pro model, which generates the actual product image.

**YOU (the user) provide the raw product info → OpenAI creates the artistic prompt → FLUX generates the image**

---

### 3. **How Does the Credit System Work?**

Let's trace what happens with credits step-by-step:

**Initial State (Before Video Generation):**
```sql
-- User has 100 credits
SELECT * FROM credits WHERE user_id = '42a140a2-b4c5-4e2e-92bd-449e87f52605';
-- Result: balance = 100, total_used = 0
```

**Step 1: Frontend Creates Video Record**
```sql
INSERT INTO videos (id, user_id, status, product_name)
VALUES (
  'bbbbbbbb-cccc-dddd-eeee-000000000001',  -- This UUID is generated by frontend
  '42a140a2-b4c5-4e2e-92bd-449e87f52605',  -- User's UUID from auth.users
  'processing',
  'Wireless Earbuds Pro'
);
```

**Step 2: Webhook Calls `deduct_credit()` Function**
```sql
-- This happens in Node 3 "Deduct Credit"
SELECT deduct_credit(
  '42a140a2-b4c5-4e2e-92bd-449e87f52605',  -- user_id
  'bbbbbbbb-cccc-dddd-eeee-000000000001'   -- video_id
);
```

**What Happens Inside the Database (Atomic Transaction):**
```sql
-- 1. Lock the user's credit row (prevents race conditions)
-- 2. Check if balance >= 1
-- 3. Update credits: balance = 99, total_used = 1
-- 4. Insert transaction record:
INSERT INTO transactions (user_id, type, amount, description, video_id)
VALUES (
  '42a140a2-b4c5-4e2e-92bd-449e87f52605',
  'deduction',
  -1,
  'Video generation',
  'bbbbbbbb-cccc-dddd-eeee-000000000001'
);
-- 5. Return TRUE (success)
```

**Step 3: If Video Generation Fails**
```sql
-- Workflow calls refund_credit()
UPDATE credits
SET balance = balance + 1, total_used = total_used - 1
WHERE user_id = '42a140a2-b4c5-4e2e-92bd-449e87f52605';

INSERT INTO transactions (user_id, type, amount, description, video_id)
VALUES (..., 'refund', 1, 'Video generation failed', ...);
```

**About the Balance Discrepancy (96 vs 99):**
Let me check the current state to clarify this confusion.

---

### 4. **The UUID System Explained**

There are **two separate UUID systems** working together:

**A. User UUID (From Supabase Auth)**
```sql
-- Created when user signs up via Supabase Auth
-- Example: 42a140a2-b4c5-4e2e-92bd-449e87f52605
-- This is stored in auth.users table
-- Used to identify WHO is making the request
```

**B. Video UUID (Generated by Frontend)**
```sql
-- Created by frontend when user clicks "Generate Video"
-- Example: bbbbbbbb-cccc-dddd-eeee-000000000001
-- This is stored in public.videos table
-- Used to track THIS SPECIFIC video generation job
```

**Why We Need Both:**
- One user can generate many videos
- Each video needs its own unique ID to track status
- Credits are tied to the user, but transactions reference specific videos

**The Foreign Key Relationship:**
```sql
-- In videos table:
user_id UUID REFERENCES auth.users(id)  -- WHO owns this video

-- In transactions table:
user_id UUID REFERENCES auth.users(id)   -- WHO spent the credit
video_id UUID REFERENCES videos(id)      -- WHICH video it was spent on
```

**This is why we got the error earlier:**
- We tried to call `deduct_credit()` with a video_id that didn't exist in the videos table
- PostgreSQL rejected it: "foreign key constraint violation"
- **Solution:** Always create the video record FIRST, then call the webhook

---

### 5. **Complete End-to-End Flow**

```
┌─────────────────────────────────────────────────────────────────────┐
│                         USER JOURNEY                                 │
└─────────────────────────────────────────────────────────────────────┘

1. USER OPENS FRONTEND
   ↓
   [React Dashboard showing "Generate New Video" button]

2. USER FILLS FORM
   ↓
   - Product Name: "Wireless Earbuds Pro"
   - Category: "Electronics"
   - Features: ["Noise cancellation", "30h battery"]
   - Target Audience: "Tech millennials"
   - Upload Photo: earbuds.jpg
   ↓
   [Frontend validates form data]

3. FRONTEND CREATES DATABASE RECORD
   ↓
   INSERT INTO videos (id, user_id, status, product_name, product_photo_url)
   VALUES (
     '123e4567-e89b-12d3-a456-426614174000',  -- Generated UUID
     currentUser.id,
     'processing',
     'Wireless Earbuds Pro',
     'https://supabase.../earbuds.jpg'
   );
   ↓
   [Database returns: Video record created successfully]

4. FRONTEND CALLS N8N WEBHOOK
   ↓
   POST https://n8n.sam9scloud.in/webhook/ugc-video-generate
   Headers: X-API-Key, Content-Type
   Body: { user_id, video_id, product_name, features, audience }
   ↓
   [Webhook receives request in Node 1 "Webhook"]

5. WORKFLOW VALIDATES REQUEST
   ↓
   Node 2: Check API Key → Valid ✓
   Node 3: Deduct Credit → Balance 100 → 99 ✓
   ↓
   [Credit deduction recorded in transactions table]

6. AI GENERATES IMAGE PROMPT
   ↓
   Node 8: Send product info to OpenAI GPT-4o-mini
   ↓
   OpenAI Response: "Professional product photography of wireless earbuds..."
   ↓
   [Clean and extract prompt text]

7. AI GENERATES PRODUCT IMAGE
   ↓
   Node 11: POST to KIE.AI FLUX API with prompt
   ↓
   KIE.AI Response: { task_id: "abc123", status: "pending" }
   ↓
   Node 13: Wait 10 seconds
   ↓
   Node 14: GET status → "processing"
   ↓
   [Loop: Wait 10s → Check status → Repeat until complete]
   ↓
   Node 14: GET status → "completed" ✓
   ↓
   Node 15: Download image → https://kie.ai/results/image.png

8. AI ANALYZES THE GENERATED IMAGE
   ↓
   Node 17: Send image to OpenAI Vision API
   Prompt: "Describe this product image in detail"
   ↓
   OpenAI Response: "The image shows sleek black wireless earbuds on a white
   surface with professional lighting. The design emphasizes premium quality..."
   ↓
   [Extract visual description for video context]

9. AI GENERATES VIDEO PROMPT
   ↓
   Node 20: Send to OpenAI GPT-4o-mini
   Context: Product info + image description
   ↓
   OpenAI Response: "Handheld camera slowly panning over wireless earbuds
   on a desk in soft natural light. Focus pulls from background to product..."
   ↓
   [Clean and format prompt for Veo]

10. AI GENERATES VIDEO
    ↓
    Node 23: POST to KIE.AI Veo 3.1 API
    Body: { prompt, first_frame_image: image.png }
    ↓
    KIE.AI Response: { task_id: "xyz789", status: "pending" }
    ↓
    Node 25: Wait 15 seconds
    ↓
    Node 26: GET status → "processing"
    ↓
    [Loop: Wait 15s → Check status → Repeat until complete]
    ↓
    Node 26: GET status → "completed" ✓
    ↓
    Node 27: Download video → https://kie.ai/results/video.mp4

11. WORKFLOW UPDATES DATABASE
    ↓
    UPDATE videos SET
      status = 'completed',
      image_url = 'https://kie.ai/results/image.png',
      video_url = 'https://kie.ai/results/video.mp4',
      image_prompt = 'Professional product photography...',
      video_prompt = 'Handheld camera slowly panning...',
      generation_time = 342  -- seconds
    WHERE id = '123e4567-e89b-12d3-a456-426614174000';
    ↓
    [Database updated successfully]

12. FRONTEND POLLS FOR COMPLETION
    ↓
    [Every 10 seconds, frontend checks:]
    SELECT status, video_url FROM videos
    WHERE id = '123e4567-e89b-12d3-a456-426614174000';
    ↓
    status = 'processing' → Show loading spinner
    ↓
    status = 'completed' → Show video player with download button

13. USER SEES FINAL VIDEO
    ↓
    [Dashboard shows completed video with preview]
    [Download button downloads video.mp4]
    [Credits remaining: 99]
```

---

## What Happens If Something Fails?

**Scenario 1: OpenAI API is down**
```
Generate Image Prompt → HTTP Error 503
↓
On Error Branch Triggered
↓
Update videos SET status = 'failed'
↓
Call refund_credit() → Balance 99 → 100
↓
Insert transaction: type = 'refund'
↓
Return error response to frontend
```

**Scenario 2: KIE.AI image generation fails**
```
Submit image job → task_id = "abc123"
↓
Poll status 10 times → Still "processing"
↓
After 100 seconds, mark as timeout
↓
Update videos SET status = 'failed'
↓
Call refund_credit()
↓
User gets credit back, can try again
```

**Scenario 3: User has insufficient credits**
```
Deduct Credit → Check balance
↓
Balance = 0 (no credits left)
↓
deduct_credit() returns FALSE
↓
Workflow stops immediately
↓
Return error: "Insufficient credits. Please purchase more."
↓
No refund needed (nothing was deducted)
```

---

## Current vs Future Architecture

### **Phase 1 (Current - Testing)**
```
Manual curl command → n8n webhook → AI APIs → Supabase → Manual check results
```

### **Phase 2 (Next - MVP Frontend)**
```
React App (Lovable) → n8n webhook → AI APIs → Supabase → Real-time updates in UI
```

### **Phase 3 (Future - Full SaaS)**
```
React App (Vercel)
  ↓
Stripe Payment → Update credits
  ↓
n8n workflow → AI APIs → Supabase
  ↓
Video storage (Cloudflare R2)
  ↓
Google Drive integration
  ↓
Analytics dashboard
```

---

## Key Takeaways for System Design

1. **The webhook is just an HTTP endpoint** - Frontend will call it like any REST API

2. **OpenAI generates the prompts** - User provides raw product info, AI makes it artistic

3. **Credits are deducted BEFORE generation starts** - Prevents abuse, refunded on failure

4. **Two UUID systems work together**:
   - User UUID (who owns the video)
   - Video UUID (tracks this specific generation job)

5. **The workflow is stateless** - All state lives in Supabase database

6. **Async processing is key** - Video takes 5-6 minutes, frontend can't wait synchronously

7. **Error handling is automatic** - Every failure path refunds credits

---

## What We Need to Design Next

Now that you understand the flow, we can discuss:

1. **Frontend Architecture**
   - How should the dashboard look?
   - Real-time progress updates (WebSocket vs polling?)
   - Video preview and download UX

2. **UGC Enhancements**
   - Where to apply the first-person narrative prompts
   - Testing strategy to avoid breaking the workflow again

3. **Scaling Considerations**
   - Batch processing (generate 10 videos at once)
   - Queue management for high volume
   - Cost optimization (caching prompts, reusing images)

4. **User Experience**
   - How to handle the 5-6 minute wait time
   - Email notifications when video is ready
   - A/B testing different prompt styles

---

Let me know which area you'd like to dive into first, and we can start planning the full system architecture together.
