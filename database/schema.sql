-- ============================================
-- RAVEN UGC PLATFORM - SUPABASE DATABASE SCHEMA
-- ============================================
-- Run this script in Supabase SQL Editor
-- This creates all tables, functions, triggers, and RLS policies
-- ============================================

-- ============================================
-- EXTENSIONS
-- ============================================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- TABLE: user_profiles
-- Extended user information linked to auth.users
-- ============================================
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name VARCHAR(255),
  company_name VARCHAR(255),
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add helpful comments
COMMENT ON TABLE user_profiles IS 'Extended user profile information';
COMMENT ON COLUMN user_profiles.id IS 'References auth.users(id)';

-- RLS Policies for user_profiles
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own profile"
  ON user_profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
  ON user_profiles FOR UPDATE
  USING (auth.uid() = id);

-- ============================================
-- TABLE: credits
-- User credit balance tracking
-- ============================================
CREATE TABLE credits (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  balance INTEGER NOT NULL DEFAULT 0 CHECK (balance >= 0),
  total_purchased INTEGER DEFAULT 0,
  total_used INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

COMMENT ON TABLE credits IS 'User credit balances for video generation';
COMMENT ON COLUMN credits.balance IS 'Current available credits (cannot be negative)';
COMMENT ON COLUMN credits.total_purchased IS 'Lifetime credits purchased/granted';
COMMENT ON COLUMN credits.total_used IS 'Lifetime credits consumed';

CREATE INDEX idx_credits_user ON credits(user_id);

-- RLS Policies for credits
ALTER TABLE credits ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own credits"
  ON credits FOR SELECT
  USING (auth.uid() = user_id);

-- Only service role can update credits (via backend/n8n)
CREATE POLICY "Service role can manage credits"
  ON credits FOR ALL
  USING (auth.role() = 'service_role');

-- ============================================
-- TABLE: videos
-- Video generation records
-- ============================================
CREATE TABLE videos (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Input Data (from user form)
  product_name VARCHAR(255) NOT NULL,
  product_photo_url TEXT NOT NULL,
  icp TEXT,                          -- Ideal Customer Profile
  features TEXT,                     -- Product features
  video_setting TEXT,                -- Video scene description
  model_selected VARCHAR(50) NOT NULL DEFAULT 'nano_veo',
  -- Options: 'nano_veo', 'veo', 'sora2'

  -- Generation Results
  status VARCHAR(20) DEFAULT 'pending',
  -- Options: 'pending', 'processing', 'completed', 'failed'
  image_prompt TEXT,                 -- Generated by OpenAI
  video_prompt TEXT,                 -- Generated by OpenAI
  generated_image_url TEXT,          -- From Nano Banana
  generated_video_url TEXT,          -- From Veo 3.1
  thumbnail_url TEXT,

  -- Metadata
  generation_time_seconds INTEGER,
  error_message TEXT,
  credits_used INTEGER DEFAULT 1,

  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE
);

COMMENT ON TABLE videos IS 'Video generation requests and results';
COMMENT ON COLUMN videos.status IS 'pending | processing | completed | failed';
COMMENT ON COLUMN videos.model_selected IS 'nano_veo | veo | sora2';

CREATE INDEX idx_videos_user_created ON videos(user_id, created_at DESC);
CREATE INDEX idx_videos_status ON videos(status);

-- RLS Policies for videos
ALTER TABLE videos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own videos"
  ON videos FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create videos"
  ON videos FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Service role needed for n8n to update video status
CREATE POLICY "Service role can update videos"
  ON videos FOR UPDATE
  USING (auth.role() = 'service_role');

-- ============================================
-- TABLE: transactions
-- Credit purchase/usage history
-- ============================================
CREATE TABLE transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type VARCHAR(20) NOT NULL CHECK (type IN ('purchase', 'deduction', 'refund')),
  amount INTEGER NOT NULL,
  description TEXT,
  video_id UUID REFERENCES videos(id) ON DELETE SET NULL,
  stripe_payment_id VARCHAR(255),    -- Phase 2: Stripe integration
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

COMMENT ON TABLE transactions IS 'Credit transaction history';
COMMENT ON COLUMN transactions.type IS 'purchase | deduction | refund';
COMMENT ON COLUMN transactions.amount IS 'Positive for purchase/refund, negative for deduction';

CREATE INDEX idx_transactions_user ON transactions(user_id, created_at DESC);

-- RLS Policies for transactions
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own transactions"
  ON transactions FOR SELECT
  USING (auth.uid() = user_id);

-- Only service role can create transactions
CREATE POLICY "Service role can create transactions"
  ON transactions FOR INSERT
  WITH CHECK (auth.role() = 'service_role');

-- ============================================
-- FUNCTION: deduct_credit
-- Atomically deduct credit and log transaction
-- Called by n8n before starting video generation
-- Returns TRUE if successful, FALSE if insufficient credits
-- ============================================
CREATE OR REPLACE FUNCTION deduct_credit(
  p_user_id UUID,
  p_video_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
  current_balance INTEGER;
BEGIN
  -- Lock row for update (prevents race conditions)
  SELECT balance INTO current_balance
  FROM credits
  WHERE user_id = p_user_id
  FOR UPDATE;

  -- Check sufficient credits
  IF current_balance IS NULL OR current_balance < 1 THEN
    RETURN FALSE;
  END IF;

  -- Deduct credit
  UPDATE credits
  SET
    balance = balance - 1,
    total_used = total_used + 1,
    updated_at = NOW()
  WHERE user_id = p_user_id;

  -- Log transaction
  INSERT INTO transactions (user_id, type, amount, description, video_id)
  VALUES (
    p_user_id,
    'deduction',
    -1,
    'Video generation',
    p_video_id
  );

  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION deduct_credit IS 'Atomically deduct 1 credit from user balance. Returns FALSE if insufficient credits.';

-- ============================================
-- FUNCTION: refund_credit
-- Refund credit if video generation fails
-- Called by n8n error handler
-- ============================================
CREATE OR REPLACE FUNCTION refund_credit(
  p_user_id UUID,
  p_video_id UUID
)
RETURNS VOID AS $$
BEGIN
  -- Refund the credit
  UPDATE credits
  SET
    balance = balance + 1,
    total_used = total_used - 1,
    updated_at = NOW()
  WHERE user_id = p_user_id;

  -- Log the refund transaction
  INSERT INTO transactions (user_id, type, amount, description, video_id)
  VALUES (
    p_user_id,
    'refund',
    1,
    'Failed generation refund',
    p_video_id
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION refund_credit IS 'Refund 1 credit to user after failed video generation.';

-- ============================================
-- FUNCTION: handle_new_user
-- Automatically create profile and grant free credits on signup
-- Triggered by new user in auth.users
-- ============================================
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- Create user profile
  INSERT INTO user_profiles (id, full_name)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', 'User')
  );

  -- Grant 5 free welcome credits
  INSERT INTO credits (user_id, balance, total_purchased)
  VALUES (NEW.id, 5, 5);

  -- Log the welcome bonus transaction
  INSERT INTO transactions (user_id, type, amount, description)
  VALUES (NEW.id, 'purchase', 5, 'Welcome bonus - 5 free credits');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION handle_new_user IS 'Creates profile and grants 5 free credits on user signup.';

-- Trigger: Run handle_new_user when a new user signs up
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- ============================================
-- FUNCTION: update_updated_at
-- Automatically update the updated_at timestamp
-- ============================================
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at trigger to relevant tables
CREATE TRIGGER update_user_profiles_updated_at
  BEFORE UPDATE ON user_profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_credits_updated_at
  BEFORE UPDATE ON credits
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- ============================================
-- STORAGE: Product Photos Bucket
-- ============================================
-- Note: Run this separately in Supabase Storage settings or SQL Editor

-- Create storage bucket for product photos
INSERT INTO storage.buckets (id, name, public)
VALUES ('product-photos', 'product-photos', false)
ON CONFLICT (id) DO NOTHING;

-- Storage policy: Users can upload their own photos
-- Files must be in a folder named with their user ID
CREATE POLICY "Users can upload own photos"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'product-photos' AND
  auth.uid()::text = (storage.foldername(name))[1]
);

-- Storage policy: Users can read their own photos
CREATE POLICY "Users can view own photos"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'product-photos' AND
  auth.uid()::text = (storage.foldername(name))[1]
);

-- Storage policy: Users can delete their own photos
CREATE POLICY "Users can delete own photos"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'product-photos' AND
  auth.uid()::text = (storage.foldername(name))[1]
);

-- ============================================
-- ADMIN UTILITIES
-- These are for manual use, not used by the application
-- ============================================

-- Example: Manually add credits to a user (admin use)
-- Replace 'user-uuid-here' with actual user ID from auth.users
/*
UPDATE credits
SET balance = balance + 25,
    total_purchased = total_purchased + 25
WHERE user_id = 'user-uuid-here';

INSERT INTO transactions (user_id, type, amount, description)
VALUES ('user-uuid-here', 'purchase', 25, 'Manual credit purchase');
*/

-- Example: Check a user's credit balance
/*
SELECT
  u.email,
  c.balance,
  c.total_purchased,
  c.total_used
FROM auth.users u
JOIN credits c ON c.user_id = u.id
WHERE u.email = 'user@example.com';
*/

-- Example: View recent video generations
/*
SELECT
  v.product_name,
  v.status,
  v.generation_time_seconds,
  v.created_at,
  v.completed_at
FROM videos v
ORDER BY v.created_at DESC
LIMIT 20;
*/

-- ============================================
-- END OF SCHEMA
-- ============================================
